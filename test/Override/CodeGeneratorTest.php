<?php
declare(strict_types=1);


namespace Neunerlei\Lockpick\Test\Override;


use Neunerlei\FileSystem\Path;
use Neunerlei\Lockpick\Override\CodeGenerator;
use Neunerlei\Lockpick\Override\Exception\ComposerCouldNotResolveTargetClassException;
use Neunerlei\Lockpick\Override\Exception\OverrideClassRenamingFailedException;
use Neunerlei\Lockpick\Test\Fixture\FixtureInvalidClass;
use Neunerlei\Lockpick\Test\Fixture\FixtureNotLoadedClass;
use Neunerlei\Lockpick\Test\Fixture\FixtureOverrideClass;
use Neunerlei\Lockpick\Test\Fixture\FixturePrivateObject;
use PHPUnit\Framework\TestCase;

class CodeGeneratorTest extends TestCase
{

    public function testAliasCodeGeneration(): void
    {
        $classToOverride = FixtureNotLoadedClass::class;
        $classToOverrideWith = FixtureOverrideClass::class;
        $copyClassFullName = '@copyClassFullName';
        $finalClassName = '@finalClassName';

        $namespace = Path::classNamespace($classToOverride);
        $baseName = Path::classBasename($classToOverride);

        $expected = <<<PHP
<?php
declare(strict_types=1);
/**
 * CLASS OVERRIDE GENERATOR - GENERATED FILE
 * This file is generated dynamically! You should not edit its contents,
 * because they will be lost as soon as the storage is cleared
 *
 * The original class can be found here:
 * @see \\$classToOverride
 *
 * The clone of the original class can be found here:
 * @see \\$copyClassFullName
 *
 * The class which is used as override can be found here:
 * @see \\$finalClassName
 */
Namespace $namespace;
if(!class_exists('\\$classToOverride', false)) {

    class $baseName
        extends \\$classToOverrideWith {}
}
PHP;

        $actual = $this->makeInstance()->getClassAliasContent(
            $classToOverride, $classToOverrideWith, $finalClassName, $copyClassFullName
        );

        static::assertEquals(
            $this->normalizeLineEndings($expected),
            $this->normalizeLineEndings($actual)
        );
    }

    public function testClassCodeGeneration(): void
    {
        $expected = <<<PHP
<?php
/**
 * CLASS OVERRIDE GENERATOR - GENERATED FILE
 * This file is generated dynamically! You should not edit its contents,
 * because they will be lost as soon as the storage is cleared
 *
 * THIS FILE IS AUTOMATICALLY GENERATED!
 *
 * This is a copy of the class: Neunerlei\Lockpick\Test\Fixture\FixturePrivateObject
 *
 * @see Neunerlei\Lockpick\Test\Fixture\FixturePrivateObject
 */

declare(strict_types=1);


namespace Neunerlei\Lockpick\Test\Fixture;


class CopyClass implements FixtureInterface
{
    protected const CONST = 'const';

    protected static int \$fooStat = 0;

    protected \$var;

    public string \$publicValue = 'Hit me!';

    protected int \$foo = 1;
    protected
    int
        \$fooNotInitialized;
    protected string \$bar = 'test';
    protected FixtureOverrideClass|FixtureSimpleClass \$class;
    protected string \$constVal = self::CONST;

    protected static array \$staticProperty = [self::CONST];

    public function __construct(protected int \$param, protected string \$constructorParam, bool \$paramB)
    {

    }

    protected function testProt(): string
    {
        return 'test';
    }

    protected
    function testPriv(int \$val): int
    {
        return \$val;
    }

    protected static function testPrivStat(): int
    {
        return 5;
    }

    /**
     * @return FixtureOverrideClass|FixtureSimpleClass|static
     */
    protected function methodWithUnionReturn(): FixtureOverrideClass|FixtureSimpleClass|static
    {
        return \$this->class;
    }

    protected function methodWithPrivateConstructorAccessor(): string
    {
        return \$this->constructorParam;
    }

    protected static function finalStatic1()
    {
        ?>
        hello world
        <?php
    }

    protected static function finalStatic2()
    {
        return [self::CONST, 'bar' => static::CONST];
    }

    function pubFuncWithoutFinal()
    {
        static::internal();
        static::\$fooStat = 2;
        \Neunerlei\Lockpick\Test\Fixture\FixturePrivateObject::\$fooStat = 2;
    }

    protected function getAnonymousClass(): object
    {
        return new class implements FixtureInterface {
            protected function test()
            {

            }

            protected function test()
            {

            }
        };
    }

    /**
     * @return static
     */
    protected function getSelf(): static
    {
        return \$this;
    }

    /**
     * @return static|static|int
     */
    protected function getSelfOrElse(): staticstatic|int
    {
        return \$this;
    }

    /**
     * @return static
     */
    static protected function internal(): static
    {
    }

    /**
     * @return static
     */
    static protected function internalFull(): static
    {
    }
}
PHP;
        $actual = $this->makeInstance()->getClassCloneContentOf(
            FixturePrivateObject::class, 'CopyClass'
        );

        static::assertEquals(
            $this->normalizeLineEndings($expected),
            $this->normalizeLineEndings($actual)
        );
    }

    public function testGetClassCloneContentOfFailIfClassCouldNotBeResolved(): void
    {
        $this->expectException(ComposerCouldNotResolveTargetClassException::class);
        $this->expectExceptionMessage('Could not create a clone of class: \Foo\Bar because Composer could not resolve it\'s filename!');
        $this->makeInstance()->getClassCloneContentOf('\\Foo\\Bar', 'Baz');
    }

    public function testGetClassCloneContentOfFailIfClassNameDoesNotMatchAutoLoadPath(): void
    {
        $this->expectException(OverrideClassRenamingFailedException::class);
        $this->expectExceptionMessage('Failed to rewrite the name of class: FixtureInvalidAutoLoadPathClass to: Baz when creating a copy of class: Neunerlei\Lockpick\Test\Fixture\FixtureInvalidAutoLoadPathClass');
        $ns = Path::classNamespace(FixtureInvalidClass::class);
        $this->makeInstance()->getClassCloneContentOf($ns . '\\FixtureInvalidAutoLoadPathClass', 'Baz');
    }

    protected function normalizeLineEndings(string $string): string
    {
        return str_replace(["\n", "\r\n"], PHP_EOL, $string);
    }

    protected function makeInstance(): CodeGenerator
    {
        return new CodeGenerator(require __DIR__ . '/../../vendor/autoload.php');
    }
}